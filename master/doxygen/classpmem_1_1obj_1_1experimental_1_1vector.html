<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PMDK C++ bindings: pmem::obj::experimental::vector&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PMDK C++ bindings
   &#160;<span id="projectnumber">1.2.0</span>
   </div>
   <div id="projectbrief">This is the C++ bindings documentation for PMDK&#39;s libpmemobj.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>pmem</b></li><li class="navelem"><b>obj</b></li><li class="navelem"><b>experimental</b></li><li class="navelem"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="classpmem_1_1obj_1_1experimental_1_1vector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pmem::obj::experimental::vector&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html" title="pmem::obj::experimental::vector - EXPERIMENTAL persistent container with std::vector compatible inter...">pmem::obj::experimental::vector</a> - EXPERIMENTAL persistent container with std::vector compatible interface.  
 <a href="classpmem_1_1obj_1_1experimental_1_1vector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="vector_8hpp_source.html">libpmemobj++/experimental/vector.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a636c3f33b0647feb03e1caf9aece8ab2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a636c3f33b0647feb03e1caf9aece8ab2">vector</a> ()</td></tr>
<tr class="memdesc:a636c3f33b0647feb03e1caf9aece8ab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a636c3f33b0647feb03e1caf9aece8ab2">More...</a><br /></td></tr>
<tr class="separator:a636c3f33b0647feb03e1caf9aece8ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77628ae4d95b0e93037541f104ec86b3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a77628ae4d95b0e93037541f104ec86b3">vector</a> (size_type count, const value_type &amp;value)</td></tr>
<tr class="memdesc:a77628ae4d95b0e93037541f104ec86b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with count copies of elements with value value.  <a href="#a77628ae4d95b0e93037541f104ec86b3">More...</a><br /></td></tr>
<tr class="separator:a77628ae4d95b0e93037541f104ec86b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486b0a598e44399198a1f05ee732e576"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a486b0a598e44399198a1f05ee732e576">vector</a> (size_type count)</td></tr>
<tr class="memdesc:a486b0a598e44399198a1f05ee732e576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with count copies of T default constructed values.  <a href="#a486b0a598e44399198a1f05ee732e576">More...</a><br /></td></tr>
<tr class="separator:a486b0a598e44399198a1f05ee732e576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f6b898490147e4c6e620785d5194aa"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename std::enable_if&lt; detail::is_input_iterator&lt; InputIt &gt;::value &amp;&amp;std::is_constructible&lt; value_type, typename std::iterator_traits&lt; InputIt &gt;::reference &gt;::value, InputIt &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ae1f6b898490147e4c6e620785d5194aa"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#ae1f6b898490147e4c6e620785d5194aa">vector</a> (InputIt first, InputIt last)</td></tr>
<tr class="memdesc:ae1f6b898490147e4c6e620785d5194aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with the contents of the range [first, last).  <a href="#ae1f6b898490147e4c6e620785d5194aa">More...</a><br /></td></tr>
<tr class="separator:ae1f6b898490147e4c6e620785d5194aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b1167a0629de37532aa57f39da47fa9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a9b1167a0629de37532aa57f39da47fa9">vector</a> (const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> &amp;other)</td></tr>
<tr class="memdesc:a9b1167a0629de37532aa57f39da47fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a9b1167a0629de37532aa57f39da47fa9">More...</a><br /></td></tr>
<tr class="separator:a9b1167a0629de37532aa57f39da47fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa503ab924495ac60140b9852ce7d52b0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aa503ab924495ac60140b9852ce7d52b0">vector</a> (<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:aa503ab924495ac60140b9852ce7d52b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="#aa503ab924495ac60140b9852ce7d52b0">More...</a><br /></td></tr>
<tr class="separator:aa503ab924495ac60140b9852ce7d52b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a88f2db2da445af0fab25559262c636"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a7a88f2db2da445af0fab25559262c636">vector</a> (std::initializer_list&lt; T &gt; init)</td></tr>
<tr class="memdesc:a7a88f2db2da445af0fab25559262c636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the container with the contents of the initializer list init.  <a href="#a7a88f2db2da445af0fab25559262c636">More...</a><br /></td></tr>
<tr class="separator:a7a88f2db2da445af0fab25559262c636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a395a49f38bcde6c2164405fc9bb2c35a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a395a49f38bcde6c2164405fc9bb2c35a">~vector</a> ()</td></tr>
<tr class="memdesc:a395a49f38bcde6c2164405fc9bb2c35a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a395a49f38bcde6c2164405fc9bb2c35a">More...</a><br /></td></tr>
<tr class="separator:a395a49f38bcde6c2164405fc9bb2c35a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b4e5d1c66f006ad7f87f9573f3c6bc"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a57b4e5d1c66f006ad7f87f9573f3c6bc">operator[]</a> (size_type n)</td></tr>
<tr class="memdesc:a57b4e5d1c66f006ad7f87f9573f3c6bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element at specific index and add it to a transaction.  <a href="#a57b4e5d1c66f006ad7f87f9573f3c6bc">More...</a><br /></td></tr>
<tr class="separator:a57b4e5d1c66f006ad7f87f9573f3c6bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f0ffcc2e74974015ed9741b1430227"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#ae1f0ffcc2e74974015ed9741b1430227">operator[]</a> (size_type n) const</td></tr>
<tr class="memdesc:ae1f0ffcc2e74974015ed9741b1430227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element at specific index.  <a href="#ae1f0ffcc2e74974015ed9741b1430227">More...</a><br /></td></tr>
<tr class="separator:ae1f0ffcc2e74974015ed9741b1430227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab88d348f9aec780a683e0572b60be83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aab88d348f9aec780a683e0572b60be83">begin</a> ()</td></tr>
<tr class="memdesc:aab88d348f9aec780a683e0572b60be83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning.  <a href="#aab88d348f9aec780a683e0572b60be83">More...</a><br /></td></tr>
<tr class="separator:aab88d348f9aec780a683e0572b60be83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb307d36ab9098655ba1a1166d37444"><td class="memItemLeft" align="right" valign="top"><a id="a3cb307d36ab9098655ba1a1166d37444"></a>
<a class="el" href="structpmem_1_1obj_1_1experimental_1_1const__contiguous__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a3cb307d36ab9098655ba1a1166d37444">begin</a> () const noexcept</td></tr>
<tr class="memdesc:a3cb307d36ab9098655ba1a1166d37444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const iterator to the beginning. <br /></td></tr>
<tr class="separator:a3cb307d36ab9098655ba1a1166d37444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac5d32b0060badd059f0ac41eb73bf54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aac5d32b0060badd059f0ac41eb73bf54">end</a> ()</td></tr>
<tr class="memdesc:aac5d32b0060badd059f0ac41eb73bf54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to past the end.  <a href="#aac5d32b0060badd059f0ac41eb73bf54">More...</a><br /></td></tr>
<tr class="separator:aac5d32b0060badd059f0ac41eb73bf54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa289592fadece20471f1588c0a1bddb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpmem_1_1obj_1_1experimental_1_1const__contiguous__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aa289592fadece20471f1588c0a1bddb3">end</a> () const noexcept</td></tr>
<tr class="memdesc:aa289592fadece20471f1588c0a1bddb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to past the end.  <a href="#aa289592fadece20471f1588c0a1bddb3">More...</a><br /></td></tr>
<tr class="separator:aa289592fadece20471f1588c0a1bddb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68621a1b88210bc2cac19f5218f7be5d"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a68621a1b88210bc2cac19f5218f7be5d">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a68621a1b88210bc2cac19f5218f7be5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the container is empty.  <a href="#a68621a1b88210bc2cac19f5218f7be5d">More...</a><br /></td></tr>
<tr class="separator:a68621a1b88210bc2cac19f5218f7be5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ae5f550e26055428de5c6bfbe103a8"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size</a> () const noexcept</td></tr>
<tr class="separator:a47ae5f550e26055428de5c6bfbe103a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e55449de7f6a9c04eaf19f3131681a7"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a8e55449de7f6a9c04eaf19f3131681a7">max_size</a> () const noexcept</td></tr>
<tr class="separator:a8e55449de7f6a9c04eaf19f3131681a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c6f34cabfe6535991feacf04745536"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity</a> () const noexcept</td></tr>
<tr class="separator:a48c6f34cabfe6535991feacf04745536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6008f5170008840628525c7e8327a2e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a6008f5170008840628525c7e8327a2e2">free_data</a> ()</td></tr>
<tr class="memdesc:a6008f5170008840628525c7e8327a2e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the content of a vector and frees all allocated persitent memory for data in transaction.  <a href="#a6008f5170008840628525c7e8327a2e2">More...</a><br /></td></tr>
<tr class="separator:a6008f5170008840628525c7e8327a2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ab667822e6db1a4ed0ea917ab75b5e02e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#ab667822e6db1a4ed0ea917ab75b5e02e">_alloc</a> (size_type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size</a>)</td></tr>
<tr class="memdesc:ab667822e6db1a4ed0ea917ab75b5e02e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper function.  <a href="#ab667822e6db1a4ed0ea917ab75b5e02e">More...</a><br /></td></tr>
<tr class="separator:ab667822e6db1a4ed0ea917ab75b5e02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae55506a53b2f29e68def838b8c32bc25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#ae55506a53b2f29e68def838b8c32bc25">_dealloc</a> ()</td></tr>
<tr class="memdesc:ae55506a53b2f29e68def838b8c32bc25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper function.  <a href="#ae55506a53b2f29e68def838b8c32bc25">More...</a><br /></td></tr>
<tr class="separator:ae55506a53b2f29e68def838b8c32bc25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e900597e407247e7c0e3d9dc1b0734e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a9e900597e407247e7c0e3d9dc1b0734e">_grow</a> (size_type count, const_reference value)</td></tr>
<tr class="memdesc:a9e900597e407247e7c0e3d9dc1b0734e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper function.  <a href="#a9e900597e407247e7c0e3d9dc1b0734e">More...</a><br /></td></tr>
<tr class="separator:a9e900597e407247e7c0e3d9dc1b0734e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e8c0c53838d13b751004eab5b60c4e7"><td class="memTemplParams" colspan="2">template&lt;typename InputIt , typename std::enable_if&lt; detail::is_input_iterator&lt; InputIt &gt;::value &amp;&amp;std::is_constructible&lt; value_type, typename std::iterator_traits&lt; InputIt &gt;::reference &gt;::value, InputIt &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a2e8c0c53838d13b751004eab5b60c4e7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a2e8c0c53838d13b751004eab5b60c4e7">_grow</a> (InputIt first, InputIt last)</td></tr>
<tr class="memdesc:a2e8c0c53838d13b751004eab5b60c4e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper function.  <a href="#a2e8c0c53838d13b751004eab5b60c4e7">More...</a><br /></td></tr>
<tr class="separator:a2e8c0c53838d13b751004eab5b60c4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab1a8a0b0f53e4d3d03fce745586669"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a2ab1a8a0b0f53e4d3d03fce745586669">_shrink</a> (size_type size_new) noexcept</td></tr>
<tr class="memdesc:a2ab1a8a0b0f53e4d3d03fce745586669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private helper function.  <a href="#a2ab1a8a0b0f53e4d3d03fce745586669">More...</a><br /></td></tr>
<tr class="separator:a2ab1a8a0b0f53e4d3d03fce745586669"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class pmem::obj::experimental::vector&lt; T &gt;</h3>

<p><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html" title="pmem::obj::experimental::vector - EXPERIMENTAL persistent container with std::vector compatible inter...">pmem::obj::experimental::vector</a> - EXPERIMENTAL persistent container with std::vector compatible interface. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a636c3f33b0647feb03e1caf9aece8ab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a636c3f33b0647feb03e1caf9aece8ab2">&#9670;&nbsp;</a></span>vector() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Constructs an empty container.</p>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class. ">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77628ae4d95b0e93037541f104ec86b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77628ae4d95b0e93037541f104ec86b3">&#9670;&nbsp;</a></span>vector() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the container with count copies of elements with value value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>number of elements to construct. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>value of all constructed elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == count </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == detail::next_pow_2(size())</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class. ">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class. ">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying array in transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
    <tr><td class="paramname">rethrows</td><td>element constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a486b0a598e44399198a1f05ee732e576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486b0a598e44399198a1f05ee732e576">&#9670;&nbsp;</a></span>vector() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the container with count copies of T default constructed values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>number of elements to construct.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == count </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == detail::next_pow_2(_size)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class. ">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class. ">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying array in transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
    <tr><td class="paramname">rethrows</td><td>element constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1f6b898490147e4c6e620785d5194aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1f6b898490147e4c6e620785d5194aa">&#9670;&nbsp;</a></span>vector() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename InputIt , typename std::enable_if&lt; detail::is_input_iterator&lt; InputIt &gt;::value &amp;&amp;std::is_constructible&lt; T, typename std::iterator_traits&lt; InputIt &gt;::reference &gt;::value, InputIt &gt;::type * &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the container with the contents of the range [first, last). </p>
<p>The first and last arguments must satisfy InputIterator requirements. This overload only participates in overload resolution if InputIt satisfies InputIterator, to avoid ambiguity with the overload of count-value constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>first iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>last iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == std::distance(first, last) </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == detail::next_pow_2(size())</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class. ">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class. ">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying array in transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
    <tr><td class="paramname">rethrows</td><td>element constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b1167a0629de37532aa57f39da47fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b1167a0629de37532aa57f39da47fa9">&#9670;&nbsp;</a></span>vector() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Constructs the container with the copy of the contents of other.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>reference to the vector to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == other.size() </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == other.capacity()</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class. ">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class. ">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying array in transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
    <tr><td class="paramname">rethrows</td><td>element constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa503ab924495ac60140b9852ce7d52b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa503ab924495ac60140b9852ce7d52b0">&#9670;&nbsp;</a></span>vector() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move constructor. </p>
<p>Constructs the container with the contents of other using move semantics. After the move, other is guaranteed to be <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a68621a1b88210bc2cac19f5218f7be5d" title="Checks whether the container is empty. ">empty()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>rvalue reference to the vector to be moved from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == other.size() </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == other.capacity() </dd>
<dd>
data() == other.data() </dd>
<dd>
other.data() == nullptr </dd>
<dd>
other.capacity() == 0 </dd>
<dd>
other.size() == 0</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class. ">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a88f2db2da445af0fab25559262c636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a88f2db2da445af0fab25559262c636">&#9670;&nbsp;</a></span>vector() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the container with the contents of the initializer list init. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">init</td><td>initializer list with content to be constructed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == init.size() </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == detail::next_pow_2(size())</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1pool__error.html" title="Custom pool error class. ">pmem::pool_error</a></td><td>if an object is not in persistent memory. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class. ">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying array in transaction failed. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>if constructor wasn't called in transaction. </td></tr>
    <tr><td class="paramname">rethrows</td><td>element constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a395a49f38bcde6c2164405fc9bb2c35a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a395a49f38bcde6c2164405fc9bb2c35a">&#9670;&nbsp;</a></span>~vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::~<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Note that free_data may throw an <a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class. ">transaction_free_error</a> when freeing underlying array failed. It is recommended to call free_data manually before object destruction. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab667822e6db1a4ed0ea917ab75b5e02e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab667822e6db1a4ed0ea917ab75b5e02e">&#9670;&nbsp;</a></span>_alloc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::_alloc </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>capacity_new</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private helper function. </p>
<p>Must be called during transaction. Allocates memory for given number of elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity_new</td><td>capacity of new underlying array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope. </dd>
<dd>
data() == nullptr </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == 0</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == capacity_new</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if new size exceeds biggest possible pmem allocation. </td></tr>
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__alloc__error.html" title="Custom transaction error class. ">pmem::transaction_alloc_error</a></td><td>when allocating memory for underlying array in transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae55506a53b2f29e68def838b8c32bc25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae55506a53b2f29e68def838b8c32bc25">&#9670;&nbsp;</a></span>_dealloc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::_dealloc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private helper function. </p>
<p>Must be called during transaction. Deallocates underlying array.</p>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == 0 </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == 0 </dd>
<dd>
data() == nullptr</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class. ">pmem::transaction_free_error</a></td><td>when freeing old underlying array failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e900597e407247e7c0e3d9dc1b0734e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e900597e407247e7c0e3d9dc1b0734e">&#9670;&nbsp;</a></span>_grow() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::_grow </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_reference&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private helper function. </p>
<p>Must be called during transaction. Assumes that there is enough space for additional elements. Copy constructs elements at the end of underlying array based on given parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>number of elements to construct. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>value of all constructed elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope. </dd>
<dd>
if initialized, range [<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aac5d32b0060badd059f0ac41eb73bf54" title="Returns an iterator to past the end. ">end()</a>, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aac5d32b0060badd059f0ac41eb73bf54" title="Returns an iterator to past the end. ">end()</a> + count) must be snapshotted in current transaction. </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> &gt;= count + <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> </dd>
<dd>
value is valid argument for value_type copy constructor.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> + count</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e8c0c53838d13b751004eab5b60c4e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e8c0c53838d13b751004eab5b60c4e7">&#9670;&nbsp;</a></span>_grow() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename InputIt , typename std::enable_if&lt; detail::is_input_iterator&lt; InputIt &gt;::value &amp;&amp;std::is_constructible&lt; T, typename std::iterator_traits&lt; InputIt &gt;::reference &gt;::value, InputIt &gt;::type * &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::_grow </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private helper function. </p>
<p>Must be called during transaction. Assumes that there is enough space for additional elements and input arguments satisfy InputIterator requirements. Constructs elements in underlying array with the contents of the range [first, last). The first and last arguments must satisfy InputIterator requirements. This overload participates in overload resolution only if InputIt satisfies InputIterator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>first iterator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>last iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope. </dd>
<dd>
if initialized, range [<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aac5d32b0060badd059f0ac41eb73bf54" title="Returns an iterator to past the end. ">end()</a>, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aac5d32b0060badd059f0ac41eb73bf54" title="Returns an iterator to past the end. ">end()</a> + std::distance(first, last)) must be snapshotted in current transaction. </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> &gt;= std::distance(first, last) + <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> </dd>
<dd>
InputIt is InputIterator. </dd>
<dd>
InputIt::reference is valid argument for value_type copy constructor.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> + std::distance(first, last)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">rethrows</td><td>constructor exception. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ab1a8a0b0f53e4d3d03fce745586669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ab1a8a0b0f53e4d3d03fce745586669">&#9670;&nbsp;</a></span>_shrink()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::_shrink </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>size_new</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private helper function. </p>
<p>Must be called during transaction. Destroys elements in underlying array beginning from position size_new.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size_new</td><td>new size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope. </dd>
<dd>
if initialized, range [<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aab88d348f9aec780a683e0572b60be83" title="Returns an iterator to the beginning. ">begin()</a>, <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#aac5d32b0060badd059f0ac41eb73bf54" title="Returns an iterator to past the end. ">end()</a>) must be snapshotted in current transaction. </dd>
<dd>
size_new &lt;= <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a></dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == size_new </dd></dl>

</div>
</div>
<a id="aab88d348f9aec780a683e0572b60be83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab88d348f9aec780a683e0572b60be83">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning. </p>
<dl class="section return"><dt>Returns</dt><dd>an iterator pointing to the first element in the vector.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48c6f34cabfe6535991feacf04745536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48c6f34cabfe6535991feacf04745536">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::size_type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>number of elements that can be held in currently allocated storage </dd></dl>

</div>
</div>
<a id="a68621a1b88210bc2cac19f5218f7be5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68621a1b88210bc2cac19f5218f7be5d">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the container is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>true if container is empty, 0 otherwise. </dd></dl>

</div>
</div>
<a id="aac5d32b0060badd059f0ac41eb73bf54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac5d32b0060badd059f0ac41eb73bf54">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1basic__contiguous__iterator.html">iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to past the end. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator referring to the past-the-end element in the vector.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa289592fadece20471f1588c0a1bddb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa289592fadece20471f1588c0a1bddb3">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::<a class="el" href="structpmem_1_1obj_1_1experimental_1_1const__contiguous__iterator.html">const_iterator</a> <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator to past the end. </p>
<dl class="section return"><dt>Returns</dt><dd>const_iterator referring to the past-the-end element in the vector. </dd></dl>

</div>
</div>
<a id="a6008f5170008840628525c7e8327a2e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6008f5170008840628525c7e8327a2e2">&#9670;&nbsp;</a></span>free_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::free_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the content of a vector and frees all allocated persitent memory for data in transaction. </p>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a47ae5f550e26055428de5c6bfbe103a8">size()</a> == 0 </dd>
<dd>
<a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html#a48c6f34cabfe6535991feacf04745536">capacity()</a> == 0 </dd>
<dd>
data() == nullptr</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__free__error.html" title="Custom transaction error class. ">pmem::transaction_free_error</a></td><td>when freeing underlying array failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e55449de7f6a9c04eaf19f3131681a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e55449de7f6a9c04eaf19f3131681a7">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::size_type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>maximum number of elements the container is able to hold due to PMDK limitations. </dd></dl>

</div>
</div>
<a id="a57b4e5d1c66f006ad7f87f9573f3c6bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57b4e5d1c66f006ad7f87f9573f3c6bc">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::reference <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access element at specific index and add it to a transaction. </p>
<p>No bounds checking is performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>index number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to nth element in underlying array.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>must be called in transaction scope.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classpmem_1_1transaction__error.html" title="Custom transaction error class. ">pmem::transaction_error</a></td><td>when adding the object to the transaction failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1f0ffcc2e74974015ed9741b1430227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1f0ffcc2e74974015ed9741b1430227">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::const_reference <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access element at specific index. </p>
<p>No bounds checking is performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>index number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const_reference to nth element in underlying array. </dd></dl>

</div>
</div>
<a id="a47ae5f550e26055428de5c6bfbe103a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ae5f550e26055428de5c6bfbe103a8">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">vector</a>&lt; T &gt;::size_type <a class="el" href="classpmem_1_1obj_1_1experimental_1_1vector.html">pmem::obj::experimental::vector</a>&lt; T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>number of elements. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>libpmemobj++/experimental/<a class="el" href="vector_8hpp_source.html">vector.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
